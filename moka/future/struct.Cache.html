<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A thread-safe, futures-aware concurrent in-memory cache."><meta name="keywords" content="rust, rustlang, rust-lang, Cache"><title>Cache in moka::future - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../moka/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Struct Cache</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.blocking_insert">blocking_insert</a><a href="#method.blocking_invalidate">blocking_invalidate</a><a href="#method.builder">builder</a><a href="#method.get">get</a><a href="#method.get_or_insert_with">get_or_insert_with</a><a href="#method.get_or_try_insert_with">get_or_try_insert_with</a><a href="#method.insert">insert</a><a href="#method.invalidate">invalidate</a><a href="#method.invalidate_all">invalidate_all</a><a href="#method.invalidate_entries_if">invalidate_entries_if</a><a href="#method.max_capacity">max_capacity</a><a href="#method.new">new</a><a href="#method.num_segments">num_segments</a><a href="#method.time_to_idle">time_to_idle</a><a href="#method.time_to_live">time_to_live</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-ConcurrentCacheExt%3CK%2C%20V%3E">ConcurrentCacheExt&lt;K, V&gt;</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><h2 class="location">Other items in<br><a href="../index.html">moka</a>::<wbr><a href="index.html">future</a></h2><div id="sidebar-vars" data-name="Cache" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">moka</a>::<wbr><a href="index.html">future</a>::<wbr><a class="struct" href="#">Cache</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/moka/future/cache.rs.html#279-282" title="goto source code">[src]</a></span></h1><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Cache&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; { /* fields omitted */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A thread-safe, futures-aware concurrent in-memory cache.</p>
<p><code>Cache</code> supports full concurrency of retrievals and a high expected concurrency
for updates. It can be accessed inside and outside of asynchronous contexts.</p>
<p><code>Cache</code> utilizes a lock-free concurrent hash table <code>SegmentedHashMap</code> from the
<a href="https://crates.io/crates/moka-cht">moka-cht</a> crate for the central key-value storage. <code>Cache</code>
performs a best-effort bounding of the map using an entry replacement algorithm
to determine which entries to evict when the capacity is exceeded.</p>
<p>To use this cache, enable a crate feature called “future”.</p>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2>
<p>Cache entries are manually added using an insert method, and are stored in the
cache until either evicted or manually invalidated:</p>
<ul>
<li>Inside an async context (<code>async fn</code> or <code>async</code> block), use
<a href="#method.insert"><code>insert</code></a>, <a href="#method.get_or_insert_with"><code>get_or_insert_with</code></a>
or <a href="#method.invalidate"><code>invalidate</code></a> method for updating the cache and <code>await</code>
them.</li>
<li>Outside any async context, use <a href="#method.blocking_insert"><code>blocking_insert</code></a> or
<a href="#method.blocking_invalidate"><code>blocking_invalidate</code></a> methods. They will block
for a short time under heavy updates.</li>
</ul>
<p>Here’s an example of reading and updating a cache by using multiple asynchronous
tasks with <a href="https://crates.io/crates/tokio">Tokio</a> runtime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// Cargo.toml</span>
 <span class="comment">//</span>
 <span class="comment">// [dependencies]</span>
 <span class="comment">// moka = { version = &quot;0.7&quot;, features = [&quot;future&quot;] }</span>
 <span class="comment">// tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot; ] }</span>
 <span class="comment">// futures = &quot;0.3&quot;</span>

 <span class="kw">use</span> <span class="ident">moka::future::Cache</span>;

 <span class="attribute">#[<span class="ident">tokio::main</span>]</span>
 <span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() {
     <span class="kw">const</span> <span class="ident">NUM_TASKS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">16</span>;
     <span class="kw">const</span> <span class="ident">NUM_KEYS_PER_TASK</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">64</span>;

     <span class="kw">fn</span> <span class="ident">value</span>(<span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">String</span> {
         <span class="macro">format!</span>(<span class="string">&quot;value {}&quot;</span>, <span class="ident">n</span>)
     }

     <span class="comment">// Create a cache that can store up to 10,000 entries.</span>
     <span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">10_000</span>);

     <span class="comment">// Spawn async tasks and write to and read from the cache.</span>
     <span class="kw">let</span> <span class="ident">tasks</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="ident">NUM_TASKS</span>)
         .<span class="ident">map</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> {
             <span class="comment">// To share the same cache across the async tasks, clone it.</span>
             <span class="comment">// This is a cheap operation.</span>
             <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
             <span class="kw">let</span> <span class="ident">start</span> <span class="op">=</span> <span class="ident">i</span> <span class="op">*</span> <span class="ident">NUM_KEYS_PER_TASK</span>;
             <span class="kw">let</span> <span class="ident">end</span> <span class="op">=</span> (<span class="ident">i</span> <span class="op">+</span> <span class="number">1</span>) <span class="op">*</span> <span class="ident">NUM_KEYS_PER_TASK</span>;

             <span class="ident">tokio::spawn</span>(<span class="kw">async</span> <span class="kw">move</span> {
                 <span class="comment">// Insert 64 entries. (NUM_KEYS_PER_TASK = 64)</span>
                 <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="ident">start</span>..<span class="ident">end</span> {
                     <span class="comment">// insert() is an async method, so await it.</span>
                     <span class="ident">my_cache</span>.<span class="ident">insert</span>(<span class="ident">key</span>, <span class="ident">value</span>(<span class="ident">key</span>)).<span class="kw">await</span>;
                     <span class="comment">// get() returns Option&lt;String&gt;, a clone of the stored value.</span>
                     <span class="macro">assert_eq!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">Some</span>(<span class="ident">value</span>(<span class="ident">key</span>)));
                 }

                 <span class="comment">// Invalidate every 4 element of the inserted entries.</span>
                 <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> (<span class="ident">start</span>..<span class="ident">end</span>).<span class="ident">step_by</span>(<span class="number">4</span>) {
                     <span class="comment">// invalidate() is an async method, so await it.</span>
                     <span class="ident">my_cache</span>.<span class="ident">invalidate</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>).<span class="kw">await</span>;
                 }
             })
         })
         .<span class="ident">collect</span>();

     <span class="comment">// Wait for all tasks to complete.</span>
     <span class="ident">futures_util::future::join_all</span>(<span class="ident">tasks</span>).<span class="kw">await</span>;

     <span class="comment">// Verify the result.</span>
     <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="number">0</span>..(<span class="ident">NUM_TASKS</span> <span class="op">*</span> <span class="ident">NUM_KEYS_PER_TASK</span>) {
         <span class="kw">if</span> <span class="ident">key</span> <span class="op">%</span> <span class="number">4</span> <span class="op">==</span> <span class="number">0</span> {
             <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">None</span>);
         } <span class="kw">else</span> {
             <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">Some</span>(<span class="ident">value</span>(<span class="ident">key</span>)));
         }
     }
 }</code></pre></div>
<p>If you want to atomically initialize and insert a value when the key is not
present, you might want to check other insertion methods
<a href="#method.get_or_insert_with"><code>get_or_insert_with</code></a> and
<a href="#method.get_or_try_insert_with"><code>get_or_try_insert_with</code></a>.</p>
<h2 id="avoiding-to-clone-the-value-at-get" class="section-header"><a href="#avoiding-to-clone-the-value-at-get">Avoiding to clone the value at <code>get</code></a></h2>
<p>The return type of <code>get</code> method is <code>Option&lt;V&gt;</code> instead of <code>Option&lt;&amp;V&gt;</code>. Every
time <code>get</code> is called for an existing key, it creates a clone of the stored value
<code>V</code> and returns it. This is because the <code>Cache</code> allows concurrent updates from
threads so a value stored in the cache can be dropped or replaced at any time by
any other thread. <code>get</code> cannot return a reference <code>&amp;V</code> as it is impossible to
guarantee the value outlives the reference.</p>
<p>If you want to store values that will be expensive to clone, wrap them by
<code>std::sync::Arc</code> before storing in a cache. <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc</code></a> is a
thread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>
<h2 id="size-based-eviction" class="section-header"><a href="#size-based-eviction">Size-based Eviction</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Cargo.toml</span>
<span class="comment">//</span>
<span class="comment">// [dependencies]</span>
<span class="comment">// moka = { version = &quot;0.7&quot;, features = [&quot;future&quot;] }</span>
<span class="comment">// tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot; ] }</span>
<span class="comment">// futures = &quot;0.3&quot;</span>

<span class="kw">use</span> <span class="ident">std::convert::TryInto</span>;
<span class="kw">use</span> <span class="ident">moka::future::Cache</span>;

<span class="attribute">#[<span class="ident">tokio::main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Evict based on the number of entries in the cache.</span>
    <span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
        <span class="comment">// Up to 10,000 entries.</span>
        .<span class="ident">max_capacity</span>(<span class="number">10_000</span>)
        <span class="comment">// Create the cache.</span>
        .<span class="ident">build</span>();
    <span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>.<span class="ident">to_string</span>()).<span class="kw">await</span>;

    <span class="comment">// Evict based on the byte length of strings in the cache.</span>
    <span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
        <span class="comment">// A weigher closure takes &amp;K and &amp;V and returns a u32</span>
        <span class="comment">// representing the relative size of the entry.</span>
        .<span class="ident">weigher</span>(<span class="op">|</span><span class="ident">_key</span>, <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">String</span><span class="op">|</span> -&gt; <span class="ident">u32</span> {
            <span class="ident">value</span>.<span class="ident">len</span>().<span class="ident">try_into</span>().<span class="ident">unwrap_or</span>(<span class="ident">u32::MAX</span>)
        })
        <span class="comment">// This cache will hold up to 32MiB of values.</span>
        .<span class="ident">max_capacity</span>(<span class="number">32</span> <span class="op">*</span> <span class="number">1024</span> <span class="op">*</span> <span class="number">1024</span>)
        .<span class="ident">build</span>();
    <span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>.<span class="ident">to_string</span>()).<span class="kw">await</span>;
}</code></pre></div>
<p>If your cache should not grow beyond a certain size, use the <code>max_capacity</code>
method of the <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a> to set the upper bound. The cache
will try to evict entries that have not been used recently or very often.</p>
<p>At the cache creation time, a weigher closure can be set by the <code>weigher</code> method
of the <code>CacheBuilder</code>. A weigher closure takes <code>&amp;K</code> and <code>&amp;V</code> as the arguments and
returns a <code>u32</code> representing the relative size of the entry:</p>
<ul>
<li>If the <code>weigher</code> is <em>not</em> set, the cache will treat each entry has the same
size of <code>1</code>. This means the cache will be bounded by the number of entries.</li>
<li>If the <code>weigher</code> is set, the cache will call the weigher to calculate the
weighted size (relative size) on an entry. This means the cache will be bounded
by the total weighted size of entries.</li>
</ul>
<p>Note that weighted sizes are not used when making eviction selections.</p>
<h2 id="time-based-expirations" class="section-header"><a href="#time-based-expirations">Time-based Expirations</a></h2>
<p><code>Cache</code> supports the following expiration policies:</p>
<ul>
<li><strong>Time to live</strong>: A cached entry will be expired after the specified duration
past from <code>insert</code>.</li>
<li><strong>Time to idle</strong>: A cached entry will be expired after the specified duration
past from <code>get</code> or <code>insert</code>.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Cargo.toml</span>
<span class="comment">//</span>
<span class="comment">// [dependencies]</span>
<span class="comment">// moka = { version = &quot;0.7&quot;, features = [&quot;future&quot;] }</span>
<span class="comment">// tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot; ] }</span>
<span class="comment">// futures = &quot;0.3&quot;</span>

<span class="kw">use</span> <span class="ident">moka::future::Cache</span>;
<span class="kw">use</span> <span class="ident">std::time::Duration</span>;

<span class="attribute">#[<span class="ident">tokio::main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
        <span class="comment">// Time to live (TTL): 30 minutes</span>
        .<span class="ident">time_to_live</span>(<span class="ident">Duration::from_secs</span>(<span class="number">30</span> <span class="op">*</span> <span class="number">60</span>))
        <span class="comment">// Time to idle (TTI):  5 minutes</span>
        .<span class="ident">time_to_idle</span>(<span class="ident">Duration::from_secs</span>( <span class="number">5</span> <span class="op">*</span> <span class="number">60</span>))
        <span class="comment">// Create the cache.</span>
        .<span class="ident">build</span>();

    <span class="comment">// This entry will expire after 5 minutes (TTI) if there is no get().</span>
    <span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>).<span class="kw">await</span>;

    <span class="comment">// This get() will extend the entry life for another 5 minutes.</span>
    <span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="number">0</span>);

    <span class="comment">// Even though we keep calling get(), the entry will expire</span>
    <span class="comment">// after 30 minutes (TTL) from the insert().</span>
}</code></pre></div>
<h2 id="thread-safety" class="section-header"><a href="#thread-safety">Thread Safety</a></h2>
<p>All methods provided by the <code>Cache</code> are considered thread-safe, and can be safely
accessed by multiple concurrent threads.</p>
<ul>
<li><code>Cache&lt;K, V, S&gt;</code> requires trait bounds <code>Send</code>, <code>Sync</code> and <code>'static</code> for <code>K</code>
(key), <code>V</code> (value) and <code>S</code> (hasher state).</li>
<li><code>Cache&lt;K, V, S&gt;</code> will implement <code>Send</code> and <code>Sync</code>.</li>
</ul>
<h2 id="sharing-a-cache-across-asynchronous-tasks" class="section-header"><a href="#sharing-a-cache-across-asynchronous-tasks">Sharing a cache across asynchronous tasks</a></h2>
<p>To share a cache across async tasks (or OS threads), do one of the followings:</p>
<ul>
<li>Create a clone of the cache by calling its <code>clone</code> method and pass it to other
task.</li>
<li>Wrap the cache by a <code>sync::OnceCell</code> or <code>sync::Lazy</code> from
<a href="https://crates.io/crates/once_cell">once_cell</a> create, and set it to a <code>static</code> variable.</li>
</ul>
<p>Cloning is a cheap operation for <code>Cache</code> as it only creates thread-safe
reference-counted pointers to the internal data structures.</p>
<h2 id="hashing-algorithm" class="section-header"><a href="#hashing-algorithm">Hashing Algorithm</a></h2>
<p>By default, <code>Cache</code> uses a hashing algorithm selected to provide resistance
against HashDoS attacks. It will be the same one used by
<code>std::collections::HashMap</code>, which is currently SipHash 1-3.</p>
<p>While SipHash’s performance is very competitive for medium sized keys, other
hashing algorithms will outperform it for small keys such as integers as well as
large keys such as long strings. However those algorithms will typically not
protect against attacks such as HashDoS.</p>
<p>The hashing algorithm can be replaced on a per-<code>Cache</code> basis using the
<a href="./struct.CacheBuilder.html#method.build_with_hasher"><code>build_with_hasher</code></a> method of the
<code>CacheBuilder</code>. Many alternative algorithms are available on crates.io, such
as the <a href="https://crates.io/crates/ahash">aHash</a> crate.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#302-333" title="goto source code">[src]</a></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V&gt; <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, <a class="struct" href="https://doc.rust-lang.org/1.58.1/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.new" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#313-324" title="goto source code">[src]</a></div><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(max_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.u64.html">u64</a>) -&gt; Self</h4></div></summary><div class="docblock"><p>Constructs a new <code>Cache&lt;K, V&gt;</code> that will store up to the <code>max_capacity</code>.</p>
<p>To adjust various configuration knobs such as <code>initial_capacity</code> or
<code>time_to_live</code>, use the <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.builder" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#330-332" title="goto source code">[src]</a></div><a href="#method.builder" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.builder" class="fnname">builder</a>() -&gt; <a class="struct" href="struct.CacheBuilder.html" title="struct moka::future::CacheBuilder">CacheBuilder</a>&lt;K, V, <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, <a class="struct" href="https://doc.rust-lang.org/1.58.1/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt;&gt;</h4></div></summary><div class="docblock"><p>Returns a <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a>, which can builds a <code>Cache</code> with
various configuration knobs.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#335-707" title="goto source code">[src]</a></div><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#374-380" title="goto source code">[src]</a></div><a href="#method.get" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get" class="fnname">get</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>Q) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns a <em>clone</em> of the value corresponding to the key.</p>
<p>If you want to store values that will be expensive to clone, wrap them by
<code>std::sync::Arc</code> before storing in a cache. <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc</code></a> is a
thread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>
<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_or_insert_with" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#463-470" title="goto source code">[src]</a></div><a href="#method.get_or_insert_with" class="anchor"></a><h4 class="code-header">pub async fn <a href="#method.get_or_insert_with" class="fnname">get_or_insert_with</a>&lt;F&gt;(&amp;self, key: K, init: F) -&gt; V <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = V&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Ensures the value of the key exists by inserting the output of the init
future if not exist, and returns a <em>clone</em> of the value.</p>
<p>This method prevents to resolve the init future multiple times on the same
key even if the method is concurrently called by many async tasks; only one
of the calls resolves its future, and other calls wait for that future to
complete.</p>
<h5 id="example" class="section-header"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Cargo.toml</span>
<span class="comment">//</span>
<span class="comment">// [dependencies]</span>
<span class="comment">// moka = { version = &quot;0.7&quot;, features = [&quot;future&quot;] }</span>
<span class="comment">// futures = &quot;0.3&quot;</span>
<span class="comment">// tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot; ] }</span>
<span class="kw">use</span> <span class="ident">moka::future::Cache</span>;
<span class="kw">use</span> <span class="ident">std::sync::Arc</span>;

<span class="attribute">#[<span class="ident">tokio::main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">const</span> <span class="ident">TEN_MIB</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">10</span> <span class="op">*</span> <span class="number">1024</span> <span class="op">*</span> <span class="number">1024</span>; <span class="comment">// 10MiB</span>
    <span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">100</span>);

    <span class="comment">// Spawn four async tasks.</span>
    <span class="kw">let</span> <span class="ident">tasks</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">4_u8</span>)
        .<span class="ident">map</span>(<span class="op">|</span><span class="ident">task_id</span><span class="op">|</span> {
            <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
            <span class="ident">tokio::spawn</span>(<span class="kw">async</span> <span class="kw">move</span> {
                <span class="macro">println!</span>(<span class="string">&quot;Task {} started.&quot;</span>, <span class="ident">task_id</span>);

                <span class="comment">// Insert and get the value for key1. Although all four async tasks</span>
                <span class="comment">// will call `get_or_insert_with` at the same time, the `init` async</span>
                <span class="comment">// block must be resolved only once.</span>
                <span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">my_cache</span>
                    .<span class="ident">get_or_insert_with</span>(<span class="string">&quot;key1&quot;</span>, <span class="kw">async</span> <span class="kw">move</span> {
                        <span class="macro">println!</span>(<span class="string">&quot;Task {} inserting a value.&quot;</span>, <span class="ident">task_id</span>);
                        <span class="ident">Arc::new</span>(<span class="macro">vec!</span>[<span class="number">0u8</span>; <span class="ident">TEN_MIB</span>])
                    })
                    .<span class="kw">await</span>;

                <span class="comment">// Ensure the value exists now.</span>
                <span class="macro">assert_eq!</span>(<span class="ident">value</span>.<span class="ident">len</span>(), <span class="ident">TEN_MIB</span>);
                <span class="macro">assert!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="string">&quot;key1&quot;</span>).<span class="ident">is_some</span>());

                <span class="macro">println!</span>(<span class="string">&quot;Task {} got the value. (len: {})&quot;</span>, <span class="ident">task_id</span>, <span class="ident">value</span>.<span class="ident">len</span>());
            })
        })
        .<span class="ident">collect</span>();

    <span class="comment">// Run all tasks concurrently and wait for them to complete.</span>
    <span class="ident">futures_util::future::join_all</span>(<span class="ident">tasks</span>).<span class="kw">await</span>;
}</code></pre></div>
<p><strong>A Sample Result</strong></p>
<ul>
<li>The <code>init</code> future (async black) was resolved exactly once by task 3.</li>
<li>Other tasks were blocked until task 3 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Task 0 started.
Task 3 started.
Task 1 started.
Task 2 started.
Task 3 inserting a value.
Task 3 got the value. (len: 10485760)
Task 0 got the value. (len: 10485760)
Task 1 got the value. (len: 10485760)
Task 2 got the value. (len: 10485760)</code></pre></div><h5 id="panics" class="section-header"><a href="#panics">Panics</a></h5>
<p>This method panics when the <code>init</code> future has been panicked. When it happens,
only the caller whose <code>init</code> future panicked will get the panic (e.g. only
task 3 in the above sample). If there are other calls in progress (e.g. task
0, 1 and 2 above), this method will restart and resolve one of the remaining
<code>init</code> futures.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_or_try_insert_with" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#562-571" title="goto source code">[src]</a></div><a href="#method.get_or_try_insert_with" class="anchor"></a><h4 class="code-header">pub async fn <a href="#method.get_or_try_insert_with" class="fnname">get_or_try_insert_with</a>&lt;F, E&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;key: K, <br>&nbsp;&nbsp;&nbsp;&nbsp;init: F<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, <a class="struct" href="https://doc.rust-lang.org/1.58.1/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;E&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, E&gt;&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;E: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h4></div></summary><div class="docblock"><p>Try to ensure the value of the key exists by inserting an <code>Ok</code> output of the
init future if not exist, and returns a <em>clone</em> of the value or the <code>Err</code>
produced by the future.</p>
<p>This method prevents to resolve the init future multiple times on the same
key even if the method is concurrently called by many async tasks; only one
of the calls resolves its future (as long as these futures return the same
error type), and other calls wait for that future to complete.</p>
<h5 id="example-1" class="section-header"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Cargo.toml</span>
<span class="comment">//</span>
<span class="comment">// [dependencies]</span>
<span class="comment">// moka = { version = &quot;0.7&quot;, features = [&quot;future&quot;] }</span>
<span class="comment">// futures = &quot;0.3&quot;</span>
<span class="comment">// reqwest = &quot;0.11&quot;</span>
<span class="comment">// tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot; ] }</span>
<span class="kw">use</span> <span class="ident">moka::future::Cache</span>;

<span class="comment">// This async function tries to get HTML from the given URI.</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">get_html</span>(<span class="ident">task_id</span>: <span class="ident">u8</span>, <span class="ident">uri</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span>, <span class="ident">reqwest::Error</span><span class="op">&gt;</span> {
    <span class="macro">println!</span>(<span class="string">&quot;get_html() called by task {}.&quot;</span>, <span class="ident">task_id</span>);
    <span class="prelude-val">Ok</span>(<span class="ident">reqwest::get</span>(<span class="ident">uri</span>).<span class="kw">await</span><span class="question-mark">?</span>.<span class="ident">text</span>().<span class="kw">await</span><span class="question-mark">?</span>)
}

<span class="attribute">#[<span class="ident">tokio::main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">100</span>);

    <span class="comment">// Spawn four async tasks.</span>
    <span class="kw">let</span> <span class="ident">tasks</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">4_u8</span>)
        .<span class="ident">map</span>(<span class="op">|</span><span class="ident">task_id</span><span class="op">|</span> {
            <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
            <span class="ident">tokio::spawn</span>(<span class="kw">async</span> <span class="kw">move</span> {
                <span class="macro">println!</span>(<span class="string">&quot;Task {} started.&quot;</span>, <span class="ident">task_id</span>);

                <span class="comment">// Try to insert and get the value for key1. Although</span>
                <span class="comment">// all four async tasks will call `get_or_try_insert_with`</span>
                <span class="comment">// at the same time, get_html() must be called only once.</span>
                <span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">my_cache</span>
                    .<span class="ident">get_or_try_insert_with</span>(
                        <span class="string">&quot;key1&quot;</span>,
                        <span class="ident">get_html</span>(<span class="ident">task_id</span>, <span class="string">&quot;https://www.rust-lang.org&quot;</span>),
                    ).<span class="kw">await</span>;

                <span class="comment">// Ensure the value exists now.</span>
                <span class="macro">assert!</span>(<span class="ident">value</span>.<span class="ident">is_ok</span>());
                <span class="macro">assert!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="string">&quot;key1&quot;</span>).<span class="ident">is_some</span>());

                <span class="macro">println!</span>(
                    <span class="string">&quot;Task {} got the value. (len: {})&quot;</span>,
                    <span class="ident">task_id</span>,
                    <span class="ident">value</span>.<span class="ident">unwrap</span>().<span class="ident">len</span>()
                );
            })
        })
        .<span class="ident">collect</span>();

    <span class="comment">// Run all tasks concurrently and wait for them to complete.</span>
    <span class="ident">futures_util::future::join_all</span>(<span class="ident">tasks</span>).<span class="kw">await</span>;
}</code></pre></div>
<p><strong>A Sample Result</strong></p>
<ul>
<li><code>get_html()</code> was called exactly once by task 2.</li>
<li>Other tasks were blocked until task 2 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Task 1 started.
Task 0 started.
Task 2 started.
Task 3 started.
get_html() called by task 2.
Task 2 got the value. (len: 19419)
Task 1 got the value. (len: 19419)
Task 0 got the value. (len: 19419)
Task 3 got the value. (len: 19419)</code></pre></div><h5 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h5>
<p>This method panics when the <code>init</code> future has been panicked. When it happens,
only the caller whose <code>init</code> future panicked will get the panic (e.g. only
task 2 in the above sample). If there are other calls in progress (e.g. task
0, 1 and 3 above), this method will restart and resolve one of the remaining
<code>init</code> futures.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.insert" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#576-580" title="goto source code">[src]</a></div><a href="#method.insert" class="anchor"></a><h4 class="code-header">pub async fn <a href="#method.insert" class="fnname">insert</a>(&amp;self, key: K, value: V)</h4></div></summary><div class="docblock"><p>Inserts a key-value pair into the cache.</p>
<p>If the cache has this key present, the value is updated.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.blocking_insert" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#586-592" title="goto source code">[src]</a></div><a href="#method.blocking_insert" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.blocking_insert" class="fnname">blocking_insert</a>(&amp;self, key: K, value: V)</h4></div></summary><div class="docblock"><p>Blocking <a href="#method.insert">insert</a> to call outside of asynchronous contexts.</p>
<p>This method is intended for use cases where you are inserting from
synchronous code.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.invalidate" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#598-610" title="goto source code">[src]</a></div><a href="#method.invalidate" class="anchor"></a><h4 class="code-header">pub async fn <a href="#method.invalidate" class="fnname">invalidate</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>Q) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></div></summary><div class="docblock"><p>Discards any cached value for the key.</p>
<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.blocking_invalidate" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#617-628" title="goto source code">[src]</a></div><a href="#method.blocking_invalidate" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.blocking_invalidate" class="fnname">blocking_invalidate</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>Q) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></div></summary><div class="docblock"><p>Blocking <a href="#method.invalidate">invalidate</a> to call outside of asynchronous
contexts.</p>
<p>This method is intended for use cases where you are invalidating from
synchronous code.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.invalidate_all" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#640-642" title="goto source code">[src]</a></div><a href="#method.invalidate_all" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate_all" class="fnname">invalidate_all</a>(&amp;self)</h4></div></summary><div class="docblock"><p>Discards all cached values.</p>
<p>This method returns immediately and a background thread will evict all the
cached values inserted before the time when this method was called. It is
guaranteed that the <code>get</code> method must not return these invalidated values
even if they have not been evicted.</p>
<p>Like the <code>invalidate</code> method, this method does not clear the historic
popularity estimator of keys so that it retains the client activities of
trying to retrieve an item.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.invalidate_entries_if" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#669-674" title="goto source code">[src]</a></div><a href="#method.invalidate_entries_if" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate_entries_if" class="fnname">invalidate_entries_if</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;predicate: F<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="../sync/type.PredicateId.html" title="type moka::sync::PredicateId">PredicateId</a>, <a class="enum" href="../enum.PredicateError.html" title="enum moka::PredicateError">PredicateError</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>K, <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>V) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.bool.html">bool</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h4></div></summary><div class="docblock"><p>Discards cached values that satisfy a predicate.</p>
<p><code>invalidate_entries_if</code> takes a closure that returns <code>true</code> or <code>false</code>. This
method returns immediately and a background thread will apply the closure to
each cached value inserted before the time when <code>invalidate_entries_if</code> was
called. If the closure returns <code>true</code> on a value, that value will be evicted
from the cache.</p>
<p>Also the <code>get</code> method will apply the closure to a value to determine if it
should have been invalidated. Therefore, it is guaranteed that the <code>get</code>
method must not return invalidated values.</p>
<p>Note that you must call
<a href="./struct.CacheBuilder.html#method.support_invalidation_closures"><code>CacheBuilder::support_invalidation_closures</code></a>
at the cache creation time as the cache needs to maintain additional internal
data structures to support this method. Otherwise, calling this method will
fail with a
<a href="../enum.PredicateError.html#variant.InvalidationClosuresDisabled"><code>PredicateError::InvalidationClosuresDisabled</code></a>.</p>
<p>Like the <code>invalidate</code> method, this method does not clear the historic
popularity estimator of keys so that it retains the client activities of
trying to retrieve an item.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.max_capacity" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#677-679" title="goto source code">[src]</a></div><a href="#method.max_capacity" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.max_capacity" class="fnname">max_capacity</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.usize.html">usize</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the <code>max_capacity</code> of this cache.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.time_to_live" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#682-684" title="goto source code">[src]</a></div><a href="#method.time_to_live" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.time_to_live" class="fnname">time_to_live</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.58.1/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the <code>time_to_live</code> of this cache.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.time_to_idle" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#687-689" title="goto source code">[src]</a></div><a href="#method.time_to_idle" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.time_to_idle" class="fnname">time_to_idle</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.58.1/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the <code>time_to_idle</code> of this cache.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.num_segments" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#694-696" title="goto source code">[src]</a></div><a href="#method.num_segments" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.num_segments" class="fnname">num_segments</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.usize.html">usize</a></h4></div></summary><div class="docblock"><p>Returns the number of internal segments of this cache.</p>
<p><code>Cache</code> always returns <code>1</code>.</p>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Clone" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#278" title="goto source code">[src]</a></div><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;K:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, V:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, S:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, S&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#278" title="goto source code">[src]</a></div><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, S&gt;</h4></div></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_from" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/clone.rs.html#130" title="goto source code">[src]</a></div><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>Self)</h4></div></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ConcurrentCacheExt%3CK%2C%20V%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#709-718" title="goto source code">[src]</a></div><a href="#impl-ConcurrentCacheExt%3CK%2C%20V%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="trait.ConcurrentCacheExt.html" title="trait moka::future::ConcurrentCacheExt">ConcurrentCacheExt</a>&lt;K, V&gt; for <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.sync" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#715-717" title="goto source code">[src]</a></div><a href="#method.sync" class="anchor"></a><h4 class="code-header">fn <a href="trait.ConcurrentCacheExt.html#tymethod.sync" class="fnname">sync</a>(&amp;self)</h4></div></summary><div class='docblock'><p>Performs any pending maintenance operations needed by the cache.</p>
</div></details></div></details><div id="impl-Send" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#286-292" title="goto source code">[src]</a></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/future/cache.rs.html#294-300" title="goto source code">[src]</a></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></h3></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, S&gt;</h3></div><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, S&gt;</h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Cache.html" title="struct moka::future::Cache">Cache</a>&lt;K, V, S&gt;</h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.58.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.58.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#549-553" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#550" title="goto source code">[src]</a></div><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#537-544" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#541" title="goto source code">[src]</a></div><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ToOwned" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;mut </a>T)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#587-596" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#593" title="goto source code">[src]</a></div><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#573-582" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#579" title="goto source code">[src]</a></div><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="moka" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
</body></html>