<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A thread-safe concurrent in-memory cache."><meta name="keywords" content="rust, rustlang, rust-lang, Cache"><title>Cache in moka::sync - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../moka/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Struct Cache</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.builder">builder</a><a href="#method.get">get</a><a href="#method.get_or_insert_with">get_or_insert_with</a><a href="#method.get_or_try_insert_with">get_or_try_insert_with</a><a href="#method.insert">insert</a><a href="#method.invalidate">invalidate</a><a href="#method.invalidate_all">invalidate_all</a><a href="#method.invalidate_entries_if">invalidate_entries_if</a><a href="#method.max_capacity">max_capacity</a><a href="#method.new">new</a><a href="#method.num_segments">num_segments</a><a href="#method.time_to_idle">time_to_idle</a><a href="#method.time_to_live">time_to_live</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-ConcurrentCacheExt%3CK%2C%20V%3E">ConcurrentCacheExt&lt;K, V&gt;</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><h2 class="location">Other items in<br><a href="../index.html">moka</a>::<wbr><a href="index.html">sync</a></h2><div id="sidebar-vars" data-name="Cache" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">moka</a>::<wbr><a href="index.html">sync</a>::<wbr><a class="struct" href="#">Cache</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/moka/sync/cache.rs.html#231-234" title="goto source code">[src]</a></span></h1><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Cache&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; { /* fields omitted */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A thread-safe concurrent in-memory cache.</p>
<p><code>Cache</code> supports full concurrency of retrievals and a high expected concurrency
for updates.</p>
<p><code>Cache</code> utilizes a lock-free concurrent hash table <code>SegmentedHashMap</code> from the
<a href="https://crates.io/crates/moka-cht">moka-cht</a> crate for the central key-value storage. <code>Cache</code>
performs a best-effort bounding of the map using an entry replacement algorithm
to determine which entries to evict when the capacity is exceeded.</p>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2>
<p>Cache entries are manually added using <a href="#method.insert"><code>insert</code></a> or
<a href="#method.get_or_insert_with"><code>get_or_insert_with</code></a> method, and are stored in the
cache until either evicted or manually invalidated.</p>
<p>Here’s an example of reading and updating a cache by using multiple threads:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;

<span class="kw">use</span> <span class="ident">std::thread</span>;

<span class="kw">fn</span> <span class="ident">value</span>(<span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">String</span> {
    <span class="macro">format!</span>(<span class="string">&quot;value {}&quot;</span>, <span class="ident">n</span>)
}

<span class="kw">const</span> <span class="ident">NUM_THREADS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">16</span>;
<span class="kw">const</span> <span class="ident">NUM_KEYS_PER_THREAD</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">64</span>;

<span class="comment">// Create a cache that can store up to 10,000 entries.</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">10_000</span>);

<span class="comment">// Spawn threads and read and update the cache simultaneously.</span>
<span class="kw">let</span> <span class="ident">threads</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="ident">NUM_THREADS</span>)
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> {
        <span class="comment">// To share the same cache across the threads, clone it.</span>
        <span class="comment">// This is a cheap operation.</span>
        <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
        <span class="kw">let</span> <span class="ident">start</span> <span class="op">=</span> <span class="ident">i</span> <span class="op">*</span> <span class="ident">NUM_KEYS_PER_THREAD</span>;
        <span class="kw">let</span> <span class="ident">end</span> <span class="op">=</span> (<span class="ident">i</span> <span class="op">+</span> <span class="number">1</span>) <span class="op">*</span> <span class="ident">NUM_KEYS_PER_THREAD</span>;

        <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="comment">// Insert 64 entries. (NUM_KEYS_PER_THREAD = 64)</span>
            <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="ident">start</span>..<span class="ident">end</span> {
                <span class="ident">my_cache</span>.<span class="ident">insert</span>(<span class="ident">key</span>, <span class="ident">value</span>(<span class="ident">key</span>));
                <span class="comment">// get() returns Option&lt;String&gt;, a clone of the stored value.</span>
                <span class="macro">assert_eq!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">Some</span>(<span class="ident">value</span>(<span class="ident">key</span>)));
            }

            <span class="comment">// Invalidate every 4 element of the inserted entries.</span>
            <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> (<span class="ident">start</span>..<span class="ident">end</span>).<span class="ident">step_by</span>(<span class="number">4</span>) {
                <span class="ident">my_cache</span>.<span class="ident">invalidate</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>);
            }
        })
    })
    .<span class="ident">collect</span>();

<span class="comment">// Wait for all threads to complete.</span>
<span class="ident">threads</span>.<span class="ident">into_iter</span>().<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">expect</span>(<span class="string">&quot;Failed&quot;</span>));

<span class="comment">// Verify the result.</span>
<span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="number">0</span>..(<span class="ident">NUM_THREADS</span> <span class="op">*</span> <span class="ident">NUM_KEYS_PER_THREAD</span>) {
    <span class="kw">if</span> <span class="ident">key</span> <span class="op">%</span> <span class="number">4</span> <span class="op">==</span> <span class="number">0</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">None</span>);
    } <span class="kw">else</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">Some</span>(<span class="ident">value</span>(<span class="ident">key</span>)));
    }
}</code></pre></div>
<p>If you want to atomically initialize and insert a value when the key is not
present, you might want to check other insertion methods
<a href="#method.get_or_insert_with"><code>get_or_insert_with</code></a> and
<a href="#method.get_or_try_insert_with"><code>get_or_try_insert_with</code></a>.</p>
<h2 id="avoiding-to-clone-the-value-at-get" class="section-header"><a href="#avoiding-to-clone-the-value-at-get">Avoiding to clone the value at <code>get</code></a></h2>
<p>The return type of <code>get</code> method is <code>Option&lt;V&gt;</code> instead of <code>Option&lt;&amp;V&gt;</code>. Every
time <code>get</code> is called for an existing key, it creates a clone of the stored value
<code>V</code> and returns it. This is because the <code>Cache</code> allows concurrent updates from
threads so a value stored in the cache can be dropped or replaced at any time by
any other thread. <code>get</code> cannot return a reference <code>&amp;V</code> as it is impossible to
guarantee the value outlives the reference.</p>
<p>If you want to store values that will be expensive to clone, wrap them by
<code>std::sync::Arc</code> before storing in a cache. <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc</code></a> is a
thread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>
<h2 id="size-based-eviction" class="section-header"><a href="#size-based-eviction">Size-based Eviction</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::convert::TryInto</span>;
<span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;

<span class="comment">// Evict based on the number of entries in the cache.</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
    <span class="comment">// Up to 10,000 entries.</span>
    .<span class="ident">max_capacity</span>(<span class="number">10_000</span>)
    <span class="comment">// Create the cache.</span>
    .<span class="ident">build</span>();
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>.<span class="ident">to_string</span>());

<span class="comment">// Evict based on the byte length of strings in the cache.</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
    <span class="comment">// A weigher closure takes &amp;K and &amp;V and returns a u32</span>
    <span class="comment">// representing the relative size of the entry.</span>
    .<span class="ident">weigher</span>(<span class="op">|</span><span class="ident">_key</span>, <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">String</span><span class="op">|</span> -&gt; <span class="ident">u32</span> {
        <span class="ident">value</span>.<span class="ident">len</span>().<span class="ident">try_into</span>().<span class="ident">unwrap_or</span>(<span class="ident">u32::MAX</span>)
    })
    <span class="comment">// This cache will hold up to 32MiB of values.</span>
    .<span class="ident">max_capacity</span>(<span class="number">32</span> <span class="op">*</span> <span class="number">1024</span> <span class="op">*</span> <span class="number">1024</span>)
    .<span class="ident">build</span>();
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>.<span class="ident">to_string</span>());</code></pre></div>
<p>If your cache should not grow beyond a certain size, use the <code>max_capacity</code>
method of the <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a> to set the upper bound. The cache
will try to evict entries that have not been used recently or very often.</p>
<p>At the cache creation time, a weigher closure can be set by the <code>weigher</code> method
of the <code>CacheBuilder</code>. A weigher closure takes <code>&amp;K</code> and <code>&amp;V</code> as the arguments and
returns a <code>u32</code> representing the relative size of the entry:</p>
<ul>
<li>If the <code>weigher</code> is <em>not</em> set, the cache will treat each entry has the same
size of <code>1</code>. This means the cache will be bounded by the number of entries.</li>
<li>If the <code>weigher</code> is set, the cache will call the weigher to calculate the
weighted size (relative size) on an entry. This means the cache will be bounded
by the total weighted size of entries.</li>
</ul>
<p>Note that weighted sizes are not used when making eviction selections.</p>
<h2 id="time-based-expirations" class="section-header"><a href="#time-based-expirations">Time-based Expirations</a></h2>
<p><code>Cache</code> supports the following expiration policies:</p>
<ul>
<li><strong>Time to live</strong>: A cached entry will be expired after the specified duration
past from <code>insert</code>.</li>
<li><strong>Time to idle</strong>: A cached entry will be expired after the specified duration
past from <code>get</code> or <code>insert</code>.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;
<span class="kw">use</span> <span class="ident">std::time::Duration</span>;

<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
    <span class="comment">// Time to live (TTL): 30 minutes</span>
    .<span class="ident">time_to_live</span>(<span class="ident">Duration::from_secs</span>(<span class="number">30</span> <span class="op">*</span> <span class="number">60</span>))
    <span class="comment">// Time to idle (TTI):  5 minutes</span>
    .<span class="ident">time_to_idle</span>(<span class="ident">Duration::from_secs</span>( <span class="number">5</span> <span class="op">*</span> <span class="number">60</span>))
    <span class="comment">// Create the cache.</span>
    .<span class="ident">build</span>();

<span class="comment">// This entry will expire after 5 minutes (TTI) if there is no get().</span>
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);

<span class="comment">// This get() will extend the entry life for another 5 minutes.</span>
<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="number">0</span>);

<span class="comment">// Even though we keep calling get(), the entry will expire</span>
<span class="comment">// after 30 minutes (TTL) from the insert().</span></code></pre></div>
<h2 id="thread-safety" class="section-header"><a href="#thread-safety">Thread Safety</a></h2>
<p>All methods provided by the <code>Cache</code> are considered thread-safe, and can be safely
accessed by multiple concurrent threads.</p>
<ul>
<li><code>Cache&lt;K, V, S&gt;</code> requires trait bounds <code>Send</code>, <code>Sync</code> and <code>'static</code> for <code>K</code>
(key), <code>V</code> (value) and <code>S</code> (hasher state).</li>
<li><code>Cache&lt;K, V, S&gt;</code> will implement <code>Send</code> and <code>Sync</code>.</li>
</ul>
<h2 id="sharing-a-cache-across-threads" class="section-header"><a href="#sharing-a-cache-across-threads">Sharing a cache across threads</a></h2>
<p>To share a cache across threads, do one of the followings:</p>
<ul>
<li>Create a clone of the cache by calling its <code>clone</code> method and pass it to other
thread.</li>
<li>Wrap the cache by a <code>sync::OnceCell</code> or <code>sync::Lazy</code> from
<a href="https://crates.io/crates/once_cell">once_cell</a> create, and set it to a <code>static</code> variable.</li>
</ul>
<p>Cloning is a cheap operation for <code>Cache</code> as it only creates thread-safe
reference-counted pointers to the internal data structures.</p>
<h2 id="hashing-algorithm" class="section-header"><a href="#hashing-algorithm">Hashing Algorithm</a></h2>
<p>By default, <code>Cache</code> uses a hashing algorithm selected to provide resistance
against HashDoS attacks. It will be the same one used by
<code>std::collections::HashMap</code>, which is currently SipHash 1-3.</p>
<p>While SipHash’s performance is very competitive for medium sized keys, other
hashing algorithms will outperform it for small keys such as integers as well as
large keys such as long strings. However those algorithms will typically not
protect against attacks such as HashDoS.</p>
<p>The hashing algorithm can be replaced on a per-<code>Cache</code> basis using the
<a href="./struct.CacheBuilder.html#method.build_with_hasher"><code>build_with_hasher</code></a> method of the
<code>CacheBuilder</code>. Many alternative algorithms are available on crates.io, such
as the <a href="https://crates.io/crates/ahash">aHash</a> crate.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#254-285" title="goto source code">[src]</a></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, <a class="struct" href="https://doc.rust-lang.org/1.58.1/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.new" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#265-276" title="goto source code">[src]</a></div><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(max_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.u64.html">u64</a>) -&gt; Self</h4></div></summary><div class="docblock"><p>Constructs a new <code>Cache&lt;K, V&gt;</code> that will store up to the <code>max_capacity</code>.</p>
<p>To adjust various configuration knobs such as <code>initial_capacity</code> or
<code>time_to_live</code>, use the <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.builder" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#282-284" title="goto source code">[src]</a></div><a href="#method.builder" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.builder" class="fnname">builder</a>() -&gt; <a class="struct" href="struct.CacheBuilder.html" title="struct moka::sync::CacheBuilder">CacheBuilder</a>&lt;K, V, <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, <a class="struct" href="https://doc.rust-lang.org/1.58.1/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt;&gt;</h4></div></summary><div class="docblock"><p>Returns a <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a>, which can builds a <code>Cache</code> or
<code>SegmentedCache</code> with various configuration knobs.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#287-683" title="goto source code">[src]</a></div><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#326-332" title="goto source code">[src]</a></div><a href="#method.get" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get" class="fnname">get</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>Q) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns a <em>clone</em> of the value corresponding to the key.</p>
<p>If you want to store values that will be expensive to clone, wrap them by
<code>std::sync::Arc</code> before storing in a cache. <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc</code></a> is a
thread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>
<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_or_insert_with" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#415-419" title="goto source code">[src]</a></div><a href="#method.get_or_insert_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_or_insert_with" class="fnname">get_or_insert_with</a>(&amp;self, key: K, init: impl <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; V) -&gt; V</h4></div></summary><div class="docblock"><p>Ensures the value of the key exists by inserting the result of the init
function if not exist, and returns a <em>clone</em> of the value.</p>
<p>This method prevents to evaluate the init closure multiple times on the same
key even if the method is concurrently called by many threads; only one of
the calls evaluates its closure, and other calls wait for that closure to
complete.</p>
<h5 id="example" class="section-header"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">sync::Arc</span>, <span class="ident">thread</span>, <span class="ident">time::Duration</span>};

<span class="kw">const</span> <span class="ident">TEN_MIB</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">10</span> <span class="op">*</span> <span class="number">1024</span> <span class="op">*</span> <span class="number">1024</span>; <span class="comment">// 10MiB</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">100</span>);

<span class="comment">// Spawn four threads.</span>
<span class="kw">let</span> <span class="ident">threads</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">4_u8</span>)
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">task_id</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
        <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="macro">println!</span>(<span class="string">&quot;Thread {} started.&quot;</span>, <span class="ident">task_id</span>);

            <span class="comment">// Try to insert and get the value for key1. Although all four</span>
            <span class="comment">// threads will call `get_or_insert_with` at the same time, the</span>
            <span class="comment">// `init` closure must be evaluated only once.</span>
            <span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">my_cache</span>.<span class="ident">get_or_insert_with</span>(<span class="string">&quot;key1&quot;</span>, <span class="op">|</span><span class="op">|</span> {
                <span class="macro">println!</span>(<span class="string">&quot;Thread {} inserting a value.&quot;</span>, <span class="ident">task_id</span>);
                <span class="ident">Arc::new</span>(<span class="macro">vec!</span>[<span class="number">0u8</span>; <span class="ident">TEN_MIB</span>])
            });

            <span class="comment">// Ensure the value exists now.</span>
            <span class="macro">assert_eq!</span>(<span class="ident">value</span>.<span class="ident">len</span>(), <span class="ident">TEN_MIB</span>);
            <span class="ident">thread::sleep</span>(<span class="ident">Duration::from_millis</span>(<span class="number">10</span>));
            <span class="macro">assert!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="string">&quot;key1&quot;</span>).<span class="ident">is_some</span>());

            <span class="macro">println!</span>(<span class="string">&quot;Thread {} got the value. (len: {})&quot;</span>, <span class="ident">task_id</span>, <span class="ident">value</span>.<span class="ident">len</span>());
        })
    })
    .<span class="ident">collect</span>();

<span class="comment">// Wait all threads to complete.</span>
<span class="ident">threads</span>
    .<span class="ident">into_iter</span>()
    .<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">expect</span>(<span class="string">&quot;Thread failed&quot;</span>));</code></pre></div>
<p><strong>Result</strong></p>
<ul>
<li>The <code>init</code> closure was called exactly once by thread 1.</li>
<li>Other threads were blocked until thread 1 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Thread 1 started.
Thread 0 started.
Thread 3 started.
Thread 2 started.
Thread 1 inserting a value.
Thread 2 got the value. (len: 10485760)
Thread 1 got the value. (len: 10485760)
Thread 0 got the value. (len: 10485760)
Thread 3 got the value. (len: 10485760)</code></pre></div><h5 id="panics" class="section-header"><a href="#panics">Panics</a></h5>
<p>This method panics when the <code>init</code> closure has been panicked. When it
happens, only the caller whose <code>init</code> closure panicked will get the panic
(e.g. only thread 1 in the above sample). If there are other calls in
progress (e.g. thread 0, 2 and 3 above), this method will restart and resolve
one of the remaining <code>init</code> closure.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_or_try_insert_with" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#526-534" title="goto source code">[src]</a></div><a href="#method.get_or_try_insert_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_or_try_insert_with" class="fnname">get_or_try_insert_with</a>&lt;F, E&gt;(&amp;self, key: K, init: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, <a class="struct" href="https://doc.rust-lang.org/1.58.1/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;E&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, E&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;E: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h4></div></summary><div class="docblock"><p>Try to ensure the value of the key exists by inserting an <code>Ok</code> result of the
init closure if not exist, and returns a <em>clone</em> of the value or the <code>Err</code>
returned by the closure.</p>
<p>This method prevents to evaluate the init closure multiple times on the same
key even if the method is concurrently called by many threads; only one of
the calls evaluates its closure (as long as these closures return the same
error type), and other calls wait for that closure to complete.</p>
<h5 id="example-1" class="section-header"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">path::Path</span>, <span class="ident">time::Duration</span>, <span class="ident">thread</span>};

<span class="doccomment">/// This function tries to get the file size in bytes.</span>
<span class="kw">fn</span> <span class="ident">get_file_size</span>(<span class="ident">thread_id</span>: <span class="ident">u8</span>, <span class="ident">path</span>: <span class="kw">impl</span> <span class="ident">AsRef</span><span class="op">&lt;</span><span class="ident">Path</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u64</span>, <span class="ident">std::io::Error</span><span class="op">&gt;</span> {
    <span class="macro">println!</span>(<span class="string">&quot;get_file_size() called by thread {}.&quot;</span>, <span class="ident">thread_id</span>);
    <span class="prelude-val">Ok</span>(<span class="ident">std::fs::metadata</span>(<span class="ident">path</span>)<span class="question-mark">?</span>.<span class="ident">len</span>())
}

<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">100</span>);

<span class="comment">// Spawn four threads.</span>
<span class="kw">let</span> <span class="ident">threads</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">4_u8</span>)
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">thread_id</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
        <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="macro">println!</span>(<span class="string">&quot;Thread {} started.&quot;</span>, <span class="ident">thread_id</span>);

            <span class="comment">// Try to insert and get the value for key1. Although all four</span>
            <span class="comment">// threads will call `get_or_try_insert_with` at the same time,</span>
            <span class="comment">// get_file_size() must be called only once.</span>
            <span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">my_cache</span>.<span class="ident">get_or_try_insert_with</span>(
                <span class="string">&quot;key1&quot;</span>,
                <span class="op">|</span><span class="op">|</span> <span class="ident">get_file_size</span>(<span class="ident">thread_id</span>, <span class="string">&quot;./Cargo.toml&quot;</span>),
            );

            <span class="comment">// Ensure the value exists now.</span>
            <span class="macro">assert!</span>(<span class="ident">value</span>.<span class="ident">is_ok</span>());
            <span class="ident">thread::sleep</span>(<span class="ident">Duration::from_millis</span>(<span class="number">10</span>));
            <span class="macro">assert!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="string">&quot;key1&quot;</span>).<span class="ident">is_some</span>());

            <span class="macro">println!</span>(
                <span class="string">&quot;Thread {} got the value. (len: {})&quot;</span>,
                <span class="ident">thread_id</span>,
                <span class="ident">value</span>.<span class="ident">unwrap</span>()
            );
        })
    })
    .<span class="ident">collect</span>();

<span class="comment">// Wait all threads to complete.</span>
<span class="ident">threads</span>
    .<span class="ident">into_iter</span>()
    .<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">expect</span>(<span class="string">&quot;Thread failed&quot;</span>));</code></pre></div>
<p><strong>Result</strong></p>
<ul>
<li><code>get_file_size()</code> was called exactly once by thread 1.</li>
<li>Other threads were blocked until thread 1 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Thread 1 started.
Thread 2 started.
get_file_size() called by thread 1.
Thread 3 started.
Thread 0 started.
Thread 2 got the value. (len: 1466)
Thread 0 got the value. (len: 1466)
Thread 1 got the value. (len: 1466)
Thread 3 got the value. (len: 1466)</code></pre></div><h5 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h5>
<p>This method panics when the <code>init</code> closure has been panicked. When it
happens, only the caller whose <code>init</code> closure panicked will get the panic
(e.g. only thread 1 in the above sample). If there are other calls in
progress (e.g. thread 0, 2 and 3 above), this method will restart and resolve
one of the remaining <code>init</code> closure.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.insert" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#568-572" title="goto source code">[src]</a></div><a href="#method.insert" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.insert" class="fnname">insert</a>(&amp;self, key: K, value: V)</h4></div></summary><div class="docblock"><p>Inserts a key-value pair into the cache.</p>
<p>If the cache has this key present, the value is updated.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.invalidate" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#584-594" title="goto source code">[src]</a></div><a href="#method.invalidate" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate" class="fnname">invalidate</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>Q) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></div></summary><div class="docblock"><p>Discards any cached value for the key.</p>
<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.invalidate_all" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#606-608" title="goto source code">[src]</a></div><a href="#method.invalidate_all" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate_all" class="fnname">invalidate_all</a>(&amp;self)</h4></div></summary><div class="docblock"><p>Discards all cached values.</p>
<p>This method returns immediately and a background thread will evict all the
cached values inserted before the time when this method was called. It is
guaranteed that the <code>get</code> method must not return these invalidated values
even if they have not been evicted.</p>
<p>Like the <code>invalidate</code> method, this method does not clear the historic
popularity estimator of keys so that it retains the client activities of
trying to retrieve an item.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.invalidate_entries_if" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#635-640" title="goto source code">[src]</a></div><a href="#method.invalidate_entries_if" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate_entries_if" class="fnname">invalidate_entries_if</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;predicate: F<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="type.PredicateId.html" title="type moka::sync::PredicateId">PredicateId</a>, <a class="enum" href="../enum.PredicateError.html" title="enum moka::PredicateError">PredicateError</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>K, <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>V) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.bool.html">bool</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h4></div></summary><div class="docblock"><p>Discards cached values that satisfy a predicate.</p>
<p><code>invalidate_entries_if</code> takes a closure that returns <code>true</code> or <code>false</code>. This
method returns immediately and a background thread will apply the closure to
each cached value inserted before the time when <code>invalidate_entries_if</code> was
called. If the closure returns <code>true</code> on a value, that value will be evicted
from the cache.</p>
<p>Also the <code>get</code> method will apply the closure to a value to determine if it
should have been invalidated. Therefore, it is guaranteed that the <code>get</code>
method must not return invalidated values.</p>
<p>Note that you must call
<a href="./struct.CacheBuilder.html#method.support_invalidation_closures"><code>CacheBuilder::support_invalidation_closures</code></a>
at the cache creation time as the cache needs to maintain additional internal
data structures to support this method. Otherwise, calling this method will
fail with a
<a href="../enum.PredicateError.html#variant.InvalidationClosuresDisabled"><code>PredicateError::InvalidationClosuresDisabled</code></a>.</p>
<p>Like the <code>invalidate</code> method, this method does not clear the historic
popularity estimator of keys so that it retains the client activities of
trying to retrieve an item.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.max_capacity" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#653-655" title="goto source code">[src]</a></div><a href="#method.max_capacity" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.max_capacity" class="fnname">max_capacity</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.usize.html">usize</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the <code>max_capacity</code> of this cache.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.time_to_live" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#658-660" title="goto source code">[src]</a></div><a href="#method.time_to_live" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.time_to_live" class="fnname">time_to_live</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.58.1/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the <code>time_to_live</code> of this cache.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.time_to_idle" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#663-665" title="goto source code">[src]</a></div><a href="#method.time_to_idle" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.time_to_idle" class="fnname">time_to_idle</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.58.1/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the <code>time_to_idle</code> of this cache.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.num_segments" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#670-672" title="goto source code">[src]</a></div><a href="#method.num_segments" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.num_segments" class="fnname">num_segments</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.usize.html">usize</a></h4></div></summary><div class="docblock"><p>Returns the number of internal segments of this cache.</p>
<p><code>Cache</code> always returns <code>1</code>.</p>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Clone" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#230" title="goto source code">[src]</a></div><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;K:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, V:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, S:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#230" title="goto source code">[src]</a></div><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h4></div></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_from" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/clone.rs.html#130" title="goto source code">[src]</a></div><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>Self)</h4></div></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ConcurrentCacheExt%3CK%2C%20V%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#685-694" title="goto source code">[src]</a></div><a href="#impl-ConcurrentCacheExt%3CK%2C%20V%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="trait.ConcurrentCacheExt.html" title="trait moka::sync::ConcurrentCacheExt">ConcurrentCacheExt</a>&lt;K, V&gt; for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.sync" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#691-693" title="goto source code">[src]</a></div><a href="#method.sync" class="anchor"></a><h4 class="code-header">fn <a href="trait.ConcurrentCacheExt.html#tymethod.sync" class="fnname">sync</a>(&amp;self)</h4></div></summary><div class='docblock'><p>Performs any pending maintenance operations needed by the cache.</p>
</div></details></div></details><div id="impl-Send" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#238-244" title="goto source code">[src]</a></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#246-252" title="goto source code">[src]</a></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></h3></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></div><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.58.1/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.58.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.58.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.58.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.58.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#549-553" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#550" title="goto source code">[src]</a></div><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#537-544" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#541" title="goto source code">[src]</a></div><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ToOwned" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.58.1/std/primitive.reference.html">&amp;mut </a>T)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.58.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#587-596" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#593" title="goto source code">[src]</a></div><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#573-582" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.58.1/src/core/convert/mod.rs.html#579" title="goto source code">[src]</a></div><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.58.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/1.58.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="moka" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
</body></html>