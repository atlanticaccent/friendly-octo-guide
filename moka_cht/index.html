<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Lock-free hash tables."><meta name="keywords" content="rust, rustlang, rust-lang, moka_cht"><title>moka_cht - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../moka_cht/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate moka_cht</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.4.2</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all moka_cht's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li></ul></div><div id="sidebar-vars" data-name="moka_cht" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">moka_cht</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/moka_cht/lib.rs.html#1-82" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Lock-free hash tables.</p>
<p>The hash tables in this crate are, at their core, open addressing hash
tables implemented using open addressing and boxed buckets. The core of
these hash tables are bucket arrays, which consist of a vector of atomic
pointers to buckets, an atomic pointer to the next bucket array, and an
epoch number. In the context of this crate, an atomic pointer is a nullable
pointer that is accessed and manipulated using atomic memory operations.
Each bucket consists of a key and a possibly-uninitialized value.</p>
<p>The key insight into making the hash table resizeable is to incrementally
copy buckets from the old bucket array to the new bucket array. As buckets
are copied between bucket arrays, their pointers in the old bucket array are
CAS’d with a null pointer that has a sentinel bit set. If the CAS fails,
that thread must read the bucket pointer again and retry copying it into the
new bucket array. If at any time a thread reads a bucket pointer with the
sentinel bit set, that thread knows that a new (larger) bucket array has
been allocated. That thread will then immediately attempt to copy all
buckets to the new bucket array. It is possible to implement an algorithm in
which a subset of buckets are relocated per-thread; such an algorithm has
not been implemented for the sake of simplicity.</p>
<p>Bucket pointers that have been copied from an old bucket array into a new
bucket array are marked with a borrowed bit. If a thread copies a bucket
from an old bucket array into a new bucket array, fails to CAS the bucket
pointer in the old bucket array, it attempts to CAS the bucket pointer in
the new bucket array that it previously inserted to. If the bucket pointer
in the new bucket array does <em>not</em> have the borrowed tag bit set, that
thread knows that the value in the new bucket array was modified more
recently than the value in the old bucket array. To avoid discarding updates
to the new bucket array, a thread will never replace a bucket pointer that
has the borrowed tag bit set with one that does not. To see why this is
necessary, consider the case where a bucket pointer is copied into the new
array, removed from the new array by a second thread, then copied into the
new array again by a third thread.</p>
<p>Mutating operations are, at their core, an atomic compare-and-swap (CAS) on
a bucket pointer. Insertions CAS null pointers and bucket pointers with
matching keys, modifications CAS bucket pointers with matching keys, and
removals CAS non-tombstone bucket pointers. Tombstone bucket pointers are
bucket pointers with a tombstone bit set as part of a removal; this
indicates that the bucket’s value has been moved from and will be destroyed
if it has not beel already.</p>
<p>As previously mentioned, removing an entry from the hash table results in
that bucket pointer having a tombstone bit set. Insertions cannot
displace a tombstone bucket unless their key compares equal, so once an
entry is inserted into the hash table, the specific index it is assigned to
will only ever hold entries whose keys compare equal. Without this
restriction, resizing operations could result in the old and new bucket
arrays being temporarily inconsistent. Consider the case where one thread,
as part of a resizing operation, copies a bucket into a new bucket array
while another thread removes and replaces that bucket from the old bucket
array. If the new bucket has a non-matching key, what happens to the bucket
that was just copied into the new bucket array?</p>
<p>Tombstone bucket pointers are typically not copied into new bucket arrays.
The exception is the case where a bucket pointer was copied to the new
bucket array, then CAS on the old bucket array fails because that bucket has
been replaced with a tombstone. In this case, the tombstone bucket pointer
will be copied over to reflect the update without displacing a key from its
bucket.</p>
<p>This hash table algorithm was inspired by <a href="https://preshing.com/20160222/a-resizable-concurrent-map/">a blog post by Jeff Phreshing</a>
that describes the implementation of the Linear hash table in <a href="https://github.com/preshing/junction">Junction</a>, a
C++ library of concurrent data structures. Additional inspiration was drawn
from the lock-free hash table described by Cliff Click in <a href="https://youtu.be/HJ-719EGIts">a tech talk</a> given
at Google in 2007.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left import-item"><code>pub use map::<a class="struct" href="map/struct.HashMap.html" title="struct moka_cht::map::HashMap">HashMap</a>;</code></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left import-item"><code>pub use segment::<a class="struct" href="segment/map/struct.HashMap.html" title="struct moka_cht::segment::map::HashMap">HashMap</a> as SegmentedHashMap;</code></div><div class="item-right docblock-short"></div></div></div><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="map/index.html" title="moka_cht::map mod">map</a></div><div class="item-right docblock-short"><p>A lock-free hash map implemented with bucket pointer arrays, open addressing,
and linear probing.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="segment/index.html" title="moka_cht::segment mod">segment</a></div><div class="item-right docblock-short"><p>Segmented lock-free hash tables.</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="moka_cht" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
</body></html>